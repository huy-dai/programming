# Compilation and Linking

## Getting Started with x86-64 Assembly on Linux

Guides: <https://p403n1x87.github.io/getting-started-with-x86-64-assembly-on-linux.html>, <https://0xax.gitbooks.io/linux-insides/content/Misc/linux-misc-3.html>

- Assemble a x64 ELF object file: `nasm -f elf64 -o hello_world.o hello_world.asm`
- (OR) If working with source C code, create object file: `gcc -c -o hello_world.o hello_world.c`
- Link our object file: 
  - w/o interpreter: `ld -o hello_world.o hello_world`
  - w/ interpreter: `ld -o hello_world hello_world.o -I/lib64/ld-linux-x86-64.so.2`
  - Alternatively, use GNU C compiler: `gcc -o hello_world.o hello_world` 
    - **Note:** Technically, gcc uses `collect2`, which is just a wrapper for GNU `ld` linker
  - For C prgrams, the `ld` command won't be sufficient for linking because you also need dependencies that define the `_start` section and related.

Even when we are not using external libraries, we still need to invoke the linker to obtain a valid executable. 

Depending on distribution, you also need to specify an **interpreter**. An interpreter is a library for ELF executables that loads the application in memory alongside required linked libraries.

Some external libraries are meant for C, so it's recommended to have a `main` function in the assembly source, since the standard C library will do some essential cleanup step when execution returns from it (ex. when working with fd or spawnin child processes).

### Aside: General Compilation Definitions

* **Object File**: Contains machine code (bytecode) and metadata generated by a compiler or assembler from soruce code. The generated object code is usually relocatable - usually containing placeholder addesses, and not usually directly executable.
  * Object file formats include: ELF, COFF, etc.

## Symbols Table + Stripping

With our `hello_world.asm` example, we are able to generate the linked `hello_world` ELF binary from it. An important part of it is the **symbol table**, which contains information that we need if we want to link our binay to other object files:

```sh
➜ wc -c < hello_world
hello_world

➜ objdump -t hello_world

hello_world:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 hello_world.asm
0000000000000001 l       *ABS*  0000000000000000 SYS_WRITE
000000000000003c l       *ABS*  0000000000000000 SYS_EXIT
0000000000000001 l       *ABS*  0000000000000000 STDOUT
0000000000402000 l       .data  0000000000000000 hello
000000000000000d l       *ABS*  0000000000000000 hello_len
0000000000401000 g       .text  0000000000000000 _start
000000000040200d g       .data  0000000000000000 __bss_start
000000000040200d g       .data  0000000000000000 _edata
0000000000402010 g       .data  0000000000000000 _end
```

We can strip off the symbols table with `strip`:

`strip -s hello_world`

Now our file shows up as "stripped", and it will no longer have symbols under `objdump`:

```sh
➜ file hello_world    
hello_world: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped

➜ objdump -t hello_world

hello_world:     file format elf64-x86-64

SYMBOL TABLE:
no symbols
```


## Relocation Stubs

Object files will have unresolved symbols (such as function locations). We can see this from the follow disassembly of `linking/main.o`:

```sh
➜ objdump -S main.o 

main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   89 7d fc                mov    %edi,-0x4(%rbp)
   f:   48 89 75 f0             mov    %rsi,-0x10(%rbp)
  13:   bf 05 00 00 00          mov    $0x5,%edi
  18:   e8 00 00 00 00          call   1d <main+0x1d>
  1d:   89 c6                   mov    %eax,%esi
  1f:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 26 <main+0x26>
  26:   48 89 c7                mov    %rax,%rdi
  29:   b8 00 00 00 00          mov    $0x0,%eax
  2e:   e8 00 00 00 00          call   33 <main+0x33>
  33:   b8 00 00 00 00          mov    $0x0,%eax
  38:   c9                      leave  
  39:   c3                      ret    
```

The `call` operation actually contains `linker stubs` (e.g. the function name and offset from to the next instruction). When linked, they will be updated to contain real addresses. 

We can ask `objdump` to show the relocation stubs with `-r` flag:

```sh
$ objdump -S -r main.o

...
13:   bf 05 00 00 00          mov    $0x5,%edi
18:   e8 00 00 00 00          call   1d <main+0x1d>
                    19: R_X86_64_PLT32      factorial-0x4
1d:   89 c6                   mov    %eax,%esi
1f:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 26 <main+0x26>
                    22: R_X86_64_PC32       .rodata-0x4
26:   48 89 c7                mov    %rax,%rdi
29:   b8 00 00 00 00          mov    $0x0,%eax
2e:   e8 00 00 00 00          call   33 <main+0x33>
                    2f: R_X86_64_PLT32      printf-0x4
33:   b8 00 00 00 00          mov    $0x0,%eax
```

Here there is also a relocation stub for the format string used in `printf` call.

**Aside:** When we look at the call instruction, we see `e8` as the instruction opcode, followed by relatively offset. But notice that `00 00 00 00` is a 4 bytes (but isn't x64 for 8 byte addresses?) 
    - Turns out that by default GCC compiles with `-mcmodel=small`, which forces "the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits."

Now if we go ahead and compile the program with all its dependencies and have it linked (automatically via gcc), we can do:

`gcc main.c lib.c -o factorial | objdump -S factorial | grep factorial`

```sh
0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    1155:       89 7d fc                mov    %edi,-0x4(%rbp)
    1158:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
    115c:       bf 05 00 00 00          mov    $0x5,%edi
    1161:       e8 1d 00 00 00          call   1183 <factorial>
    1166:       89 c6                   mov    %eax,%esi
    1168:       48 8d 05 95 0e 00 00    lea    0xe95(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    116f:       48 89 c7                mov    %rax,%rdi
    1172:       b8 00 00 00 00          mov    $0x0,%eax
    1177:       e8 d4 fe ff ff          call   1050 <printf@plt>
    117c:       b8 00 00 00 00          mov    $0x0,%eax
    1181:       c9                      leave  
    1182:       c3                      ret    

0000000000001183 <factorial>:
    1183:       f3 0f 1e fa             endbr64 
    1187:       55                      push   %rbp
```

We can see that now the symbol for `factorial` is resolved and its addresses is now properly populated in the `call` instruction inside `main`.

## `.init`

In an ELF file, the `.init` section holds code to be executed before the main program entry point. It is meant to set up global variables, allocate memory, calling other init functions, etc. 

For example, in our test example, `.init` calls `__gmon_start__`, which initializes the gmon profiling system. 

```sh
Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64 
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret    
```

## `.interp`

The `.interp` section in the ELF file holds the ASCI path name of the program interpreter. The interpreter i mean to be a dynamic linker that loads and links shared libraried needed by an executable when executed. This is doen by copying content of libraries from disk to RAM. 

We can view this string via `objdump`:

```sh
➜ objdump -s -j .interp factorial

factorial:     file format elf64-x86-64

Contents of section .interp:
 0318 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
 0328 7838362d 36342e73 6f2e3200           x86-64.so.2. 
```

## `.start`

`.start` represents the main entry point of an ELF program.

Our C `main` function is actually invoked inside the `.start` section via the `__libc_start_main`, which looks like the following:

```sh
0000000000001060 <_start>:
    1060:       f3 0f 1e fa             endbr64 
    1064:       31 ed                   xor    %ebp,%ebp
    1066:       49 89 d1                mov    %rdx,%r9
    1069:       5e                      pop    %rsi
    106a:       48 89 e2                mov    %rsp,%rdx
    106d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
    1071:       50                      push   %rax
    1072:       54                      push   %rsp
    1073:       45 31 c0                xor    %r8d,%r8d
    1076:       31 c9                   xor    %ecx,%ecx
    1078:       48 8d 3d ca 00 00 00    lea    0xca(%rip),%rdi        # 1149 <main>
    107f:       ff 15 53 2f 00 00       call   *0x2f53(%rip)        # 3fd8 <__libc_start_main@GLIBC_2.34>
    1085:       f4                      hlt    
    1086:       66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)
    108d:       00 00 00 
```

Notice that the address of `main` is calculated with `lea 0xca(%rip), %rdi`. If you recall, address of `main` is `0x1149`. The way we get to this calculation is:

`0x107f + 0xca = 0x1149`

Notice that we use the address of the **next instruction**, instead of the one we are at. Remember that `RIP` is meant to hold address of next instruction, and that with x64 the instructions are variable sized (here I used the assembly + address output to get that address).

Also remember that x64 is little endian, which means when you see offset being represented as `ca 00 00 00` in binary, it's actually `0xca`



## Helping Utilities

- `nm` to list symbol tables of object files, executables, or object library

Example output:

```sh
➜ nm -A main.o
main.o:                 U factorial
main.o:0000000000000000 T main
main.o:                 U printf
```

`T` is text (code), `D` is data (initialized data), `B` is BSS (uninitialized data), `U` is undefined (symbol not defined in this file), and `A` is absolute (symbol with fixed address)

Note that `factorial` (from an imported `.h` file) and `printf` (from libc) are Unknown here because we have not done the linking process yet for this example. Also `main` function is at address `0000000000000000` because it is not filled yet by the linker.

- `objdump` to display information about object file, diassembly of functions

```sh
$ objdump -S main.o

main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 <main>:
   0:    55                       push   %rbp
   1:    48 89 e5                 mov    %rsp,%rbp
   4:    48 83 ec 10              sub    $0x10,%rsp
   ...
```

- `readelf` provides detailed information about ELF files 

If you want to see the dynamic section, which contains information about dynamic linking, use the `-d` flag:

```sh
➜ readelf -d factorial   

Dynamic section at offset 0x2dc8 contains 27 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x11c0
 ...
 0x0000000000000003 (PLTGOT)             0x3fb8
 0x0000000000000002 (PLTRELSZ)           24 (bytes)
 ...
```